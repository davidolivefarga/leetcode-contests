# Weekly Contest 2

You can find the contest [here](https://leetcode.com/contest/leetcode-weekly-contest-2).

This is the list of problems for this contest:

- [Find the Difference](#find-the-difference) (easy)
- [Elimination Game](#elimination-game) (medium)
- [Perfect Rectangle](#perfect-rectangle) (hard)

## Find the Difference

### Description

You are given two strings `s` and `t`.

String `t` is generated by random shuffling string `s` and then add one more letter at a random position.

Return the letter that was added to `t`.

It is guaranteed that `s` and `t` consist only of lower-case letters.

### Solution

Count the frequency of each character. Characters of `s` decrease the frequency, while characters of `t` increase it. At the end of the process, the extra character will be the only one with frequency 1 (all other will have frequency 0).

```js
/*
Complexity:
- Time: O(n)
- Memory: O(1)
*/

var findTheDifference = function(s, t) {
    if (!s) return t;
    
    const frequencies = {};

    for (let c of s) frequencies[c] = (frequencies[c] || 0) - 1;
    for (let c of t) frequencies[c] = (frequencies[c] || 0) + 1;
    
    return 'abcdefghijklmnopqrstuvwxyz'.split('').find(c => frequencies[c] == 1);
};
```

## Elimination Game

### Description

There is a list of sorted integers from 1 to `n`. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.

Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.

We keep repeating the steps again, alternating left to right and right to left, until a single number remains.

Find the last number that remains starting with a list of length `n`.

### Solution

This is an interesting problem, so I'll try to describe my thought process with detail.

You can go for the naive approach and create an array of numbers, apply the process and find the result... But maybe we can do better (spoilers: we can).

With these kind of problems, the best idea is to start with some manual calculations to see if we can get an inituition.

Denote by `f(n)` the remaining number we obtain with a list of length `n`. This is the list of the first 10 numbers:

| `n` | `f(n)` |
| :--- | :---: |
| 1 | 1 |
| 2 | 2 |
| 3 | 2 |
| 4 | 2 |
| 5 | 2 |
| 6 | 4 |
| 7 | 4 |
| 8 | 6 |
| 9 | 6 |
| 10 | 8 |

The first thing we can observe is that `f(2k + 1) = f(2k)`. This is very easy to prove, since in both lists we end up with same list of numbers after the first iteration of the process. This means we only need to focus on calculating `f(2k)`.

The second thing we can observe is that there seems to be another pattern, in which `f(2k) = 2k - 2`. You can try to submit this solution without proving this theory first (I did), but you'll be welcomed with a Wrong Answer message (as I was). For example, `f(12) = 6`. You know, trying a few numbers doesn't always reveal the right pattern...

Ok, so this means we need to find a different approach. For example, is there a way to express `f(n)` in terms of other values? 

Let's check what happens with `n = 12`

```
Initially: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
1st iteration: [2, 4, 6, 8, 10, 12]
2nd iteration: [2, 6, 10]
```

We have `[2, 4, 6, 8, 10, 12] = 2 * [1, 2, 3, 4, 5, 6]`. This looks promising! However, we can't do `f(12) = 2 * f(6)`, because the next iteration is from right-to-left. What makes it worse is that after the 2nd iteration, we have `[2, 6, 10] = 2 * [1, 3 ,5]`, which is not even a full list.

Well, when you don't know something, put a name to it. Since we called the left-to-right process `f(n)`, let's call the right-to-left process `g(n)`. This way, we have `f(2k) = 2 * g(k)`.

Since we introduced a new function, we can update the previous table and calculate some more values:

| `n` | `f(n)` | `g(n)` |
| :--- | :---: | :---: |
| 1 | 1 | 1 |
| 2 | 2 | 1 |
| 3 | 2 | 2 |
| 4 | 2 | 3 |
| 5 | 2 | 4 |
| 6 | 4 | 3 |
| 7 | 4 | 4 |
| 8 | 6 | 3 |
| 9 | 6 | 4 |
| 10 | 8 | 3 |

There seems to be yet another interesting pattern: `f(n) + g(n) = n + 1`. This time, let's try to prove it before risking another Wrong Answer.

Picking back the previous example, we want to calculate `g(6)`, that is, apply the right-to-left process to `[1, 2, 3, 4, 5, 6]`. For this to yield the same result as `f(6)`, we would actually need to apply the right-to-left process to `[6, 5, 4, 3, 2, 1]`. Notice that `1 + 6 = 2 + 5 = ... = 7`. This means we can apply a transformation to `[1, 2, 3, 4, 5, 6]` by replacing every number `i` by `7 - i`, giving us `[6, 5, 4, 3, 2, 1]`. That is, `g(6) = 7 - f(6)`, or in other words, `f(6) + g(6) = 7`.

The above argument can be generalised to prove our pattern `f(n) + g(n) = n + 1`.

Combining this with what we already knew, we have `f(2k) = 2 * g(k) = 2 * (k + 1 - f(k))` or `f(k) = 2 * g(k / 2) = 2 * (k / 2 + 1 - f(k / 2))`.

```js
/*
Complexity:
- Time: O(log(n))
- Memory: O(1)
*/

var lastRemaining = function(n) {
    if (n == 1) return 1;
    if (n % 2 == 1) return lastRemaining(n - 1);
    
    return 2 * (n / 2 + 1 - lastRemaining(n / 2));
};
```

## Perfect Rectangle

TODO